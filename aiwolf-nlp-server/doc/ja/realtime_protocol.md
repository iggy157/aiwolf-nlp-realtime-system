# リアルタイム通信プロトコルについて

このドキュメントでは、リアルタイム（グループチャット方式）通信プロトコルについて説明します。

## 概要

従来のターン制プロトコルでは、サーバがエージェントに順番にトークリクエストを送信し、エージェントが応答する形式でした。
リアルタイムプロトコルでは、エージェントは任意のタイミングで発言でき、発言は即座に全エージェントにブロードキャストされます。

これにより、グループチャットのような自然な会話の流れが実現されます。

## 設定

```yaml
game:
  realtime:
    enable: true            # リアルタイムモードを有効にする
    phase_timeout: 120s     # トークフェーズ全体の制限時間
    silence_timeout: 15s    # 全員が沈黙した場合のタイムアウト
    rate_limit: 2s          # 1エージェントの最小発言間隔
```

`enable: false` にすると、従来のターン制プロトコルが使用されます。

## プロトコルの流れ

### 1. フェーズ開始 (TALK_START / WHISPER_START)

サーバからエージェントにフェーズ開始が通知されます。

```
サーバ → 全エージェント:
{
  "request": "TALK_START",
  "info": { ... },          // 現在のゲーム状態
  "setting": { ... },       // ゲーム設定
  "talk_history": [ ... ]   // これまでのトーク履歴
}
```

エージェントはレスポンスを返す必要はありません。
このパケットを受信したら、会話の監視と発言の準備を開始してください。

### 2. 発言 (エージェント → サーバ)

エージェントは任意のタイミングで発言をサーバに送信できます。
従来と同様、生の文字列（JSON ではない）で送信します。

```
エージェント → サーバ: "私は占い師です。Agent[03]を占ったら人狼でした。"
```

特殊な文字列:
- `Over` - このフェーズでの発言を終了する
- `Skip` - 何も発言しない（無視される）

### 3. ブロードキャスト (TALK_BROADCAST / WHISPER_BROADCAST)

誰かが発言すると、サーバから全エージェントに即座にブロードキャストされます。

```
サーバ → 全エージェント:
{
  "request": "TALK_BROADCAST",
  "info": {
    "game_id": "...",
    "day": 1,
    "agent": "Agent[01]",       // 受信者自身
    "remain_count": 8           // 受信者の残り発言回数
  },
  "talk_history": [
    {
      "idx": 5,
      "day": 1,
      "turn": 0,
      "agent": "Agent[03]",    // 発言者
      "text": "私は占い師です。Agent[03]を占ったら人狼でした。",
      "skip": false,
      "over": false
    }
  ]
}
```

エージェントはこのブロードキャストを受信して、会話の流れを把握し、
返答すべきかどうかを自分で判断します。

### 4. フェーズ終了 (TALK_END / WHISPER_END)

以下のいずれかの条件で、サーバからフェーズ終了が通知されます:
- 全エージェントが `Over` を送信した
- フェーズの制限時間 (`phase_timeout`) に達した
- 一定時間誰も発言しなかった (`silence_timeout`)

```
サーバ → 全エージェント:
{
  "request": "TALK_END"
}
```

## 制約

- **発言回数**: `talk.max_count.per_agent` で設定された回数まで発言可能
- **文字数制限**: `talk.max_length.per_talk` で設定された文字数まで（超過分は切り捨て）
- **レートリミット**: `realtime.rate_limit` で設定された間隔より短い連続発言は無視される
- **エラー時**: エージェントの接続エラーが発生した場合、そのエージェントは以降のリクエストに応答できなくなります

## エージェント実装のガイドライン

リアルタイムモードでは、エージェントは以下のように実装する必要があります:

1. **常時受信**: WebSocket からのメッセージを常に監視する
2. **リクエストの判別**: 受信したJSON の `request` フィールドで処理を分岐する
   - `TALK_START` → フェーズ開始、会話の準備
   - `TALK_BROADCAST` → 新しい発言の受信、返答すべきか判断
   - `TALK_END` → フェーズ終了、次のリクエスト（投票等）を待つ
   - `VOTE`, `DIVINE`, etc. → 従来通りのリクエスト/レスポンス
3. **自律的な発言判断**: サーバからの指示を待つのではなく、自分で「今話すべきか」を判断する
4. **`Over` の送信**: 発言することがなくなったら `Over` を送信する

### 発言タイミングの判断例

```
# 話すべき場面:
- 自分が名指しで質問された
- 重要な情報（占い結果など）を共有したい
- 議論が停滞していて話題を提供すべき
- 誰かの主張に反論したい

# 聞くべき場面:
- 他の人の発言が続いている最中
- 自分に関係ない議論が行われている
- さっき発言したばかり
- まだ情報が不足していて判断できない
```

## 従来プロトコルとの互換性

リアルタイムモードが無効 (`realtime.enable: false`) の場合、
従来のターン制プロトコルがそのまま使用されます。
投票 (`VOTE`)、占い (`DIVINE`)、護衛 (`GUARD`)、襲撃 (`ATTACK`) などの
夜フェーズのリクエストは、リアルタイムモードの有無に関わらず
従来通りのリクエスト/レスポンス形式です。